{
  
    
        "post0": {
            "title": "Notes on SimCLR - A Simple Framework for Contrastive Learning of Visual Representations",
            "content": "A Simple Framework for Contrastive Learning of Visual Representations1 . Note: All quotes and images used in this page belong to the authors of the paper. If you intend to use them, please give the deserved credits. Furthermore, all images and tables captions map to the captions of the paper. . This work1 shows: . Composition of data augmentations | NT-Xent, Normalized Temperature-scaled Cross-Entropy, a learnable nonlinear transformation between the representation and the contrastive loss | Contrastive learning benefits from larger batch sizes | . The method . Composition of data augmentations . A stochastic data augmentation module that transforms any given data example randomly resulting in two correlated views of the same example denoted $ tilde{x}_i text{and } tilde{x}_j$, which we consider as a positive pair. . Composition of multiple data augmentation operations is crucial in defining the contrastive prediction tasks that yield effective representations. (...) . Figure 2. (partial) A simple framework for contrastive learning of visual representations . $x$ is the input image . | $ tilde{x}_i text{and } tilde{x}_j$ are transformed images . | $ mathcal{t}$ is a sequentialy applied simple augmentations . | $ mathcal{T}$ is a set of simple augmentations . | . The base encoder . Figure 2. (partial) A simple framework for contrastive learning of visual representations . $f( cdot)$ is a neural network base encoder . | $h_i$ and $h_j$ is the output after the average pooling layer where $h_i in mathbb{R}^{d}$ . | . The projection head . Figure 2. A simple framework for contrastive learning of visual representations . A small neural network projection head $g( cdot)$ that maps representations to the space where contrastive loss is applied. | . The contrastive loss function . $$ mathsf{sim}(u,v) = dfrac{u^ intercal v}{ |u | |v |} $$ . $$ $$ . $$ ell_{i,j} = - log dfrac{ exp mathsf{sim}(z_i, z_j) / tau}{ sum_{k=1}^{2N} mathbb{1}_{[k ne i]} exp mathsf{sim}(z_i, z_j) / tau} , (1) $$ . Given a set $ {x_k }$ including a positive pair of examples $x_i$ and $x_j$, the contrastive prediction task aims to identify $x_j$ in $ { tilde{x}_k }_{k neq i}$ for a given $ tilde{x}_i$. . The final loss is computed across all positive pairs, both $(i, j)$ and $(j, i)$, in a mini-batch/ . . A tale of large batch sizes . We do not train the model with a memory bank (Wu et al.,2018). Instead, we vary the training batch size N from 256 to 8192.&gt; Training with large batch size may be unstable when using standard SGD/Momentum with linear learning rate scaling (Goyal et al., 2017). To stabilize the training, we use the LARS2 optimizer (You et al., 2017) for all batch sizes. . 2. LARS, Large Batch Training of Convolutional Networks↩ . Dataset and metrics . Most of our study for unsupervised pretraining (learning encoder network f without labels) is done using the ImageNet ILSVRC-2012 dataset (...) . To evaluate the learned representations, we follow the widely used linear evaluation protocol (Zhang et al., 2016; Oord et al., 2018; Bachman et al., 2019; Kolesnikov et al., 2019), where a linear classifier is trained on top of the frozen base network, and test accuracy is used as a proxy for representation quality. . Beyond linear evaluation, we also compare against state-of-the-art on semi-supervised and transfer learning. . Default setting . (...) for data augmentation we use random crop and resize (with random flip), color distortions, and Gaussian blur (..) . $ mathcal T = { text{crop and resize, color distortions, and Gaussian blur} }$ | . We use ResNet-50 as the base encoder network (...) . $h_i = f( tilde x_i) = text{ResNet}( tilde{x}_i)$ where $h_i in mathbb{R}^{2048}$ | . (...) 2-layer MLP projection head to project the representation to a 128-dimensional latent space (...) . $z_i = g(h_i) = W^{(2)} sigma(W^{(1)}h_i), sigma = text{ReLU}$ where $z_i in mathbb{R}^{128}$ | . (...) optimized using LARS with linear learning rate scaling (i.e. $ text{LearningRate = 0.3 × BatchSize/256}$) and weight decay of $10^{-6}$. We train at batch size 4096 for 100 epochs (...) . Data Augmentation for Contrastive Representation Learning . Composition of data augmentation operations is crucial for learning good representations . The authors decided to consider several common augmentations: . spatial/geometric transformation - cropping, resizing, horizontal flipping, rotation and cutout | appearance transformation - color distortion (including color dropping, brightness, contrast, saturation,hue), Gaussian blur, and Sobel filtering | . Figure 5. Linear evaluation (ImageNet top-1 accuracy) under individual or composition of data augmentations, applied only to one branch. . We observe that no single transformation suffices to learn good representations (...) When composing augmentations, the contrastive prediction task becomes harder, but the quality of representation improves dramatically . Random cropping and random color distortion . Figure 6. Histograms of pixel intensities (over all channels) for different crops of two different images. . Neural nets may exploit this shortcut to solve the predictive task. Therefore, it is critical to compose cropping with color distortion in order to learn generalizable features. . Findings . A nonlinear projection head improves the representation quality of the layer before it . Figure 8. Linear evaluation of representations with different projection heads $g( cdot)$ and various dimensions of $z = g(h)$. . Normalized cross entropy loss with adjustable temperature works better than alternatives . Table 4. Linear evaluation (top-1) for models trained with different loss functions. “sh” means using semi-hard negative mining. . Table 5. Linear evaluation for models trained with different choices of $ ell_{2}$ norm and temperature $ tau$ for NT-Xent loss. . Contrastive learning benefits (more) from larger batch sizes and longer training . Figure 9. Linear evaluation models (ResNet-50) trained with different batch size and epochs. Each bar is a single run from scratch. . Comparison with State-of-the-art . Table 8. Comparison of transfer learning performance of our self-supervised approach with supervised baselines across 12 natural image classification datasets, for ResNet-50 (4×) models pretrained on ImageNet. . Not only does SimCLR outperform previous work (Figure 1), but it is also simpler, requiring neither specialized architectures (...) . Figure 1. ImageNet Top-1 accuracy of linear classifiers trained on representations learned with different self-supervised methods (pretrained on ImageNet). . Conclusions . In this work, we present a simple framework and its instantiation for contrastive visual representation learning. We carefully study its components, and show the effects of different design choices. . Our approach differs from standard supervised learning on ImageNet only in the choice of data augmentation, the use of a nonlinear head at the end of the network, and the loss function. . The strength of this simple framework suggests that, despite a recent surge in interest, self-supervised learning remains undervalued. . Code samples . . Note: In this section I am highlighting some rather important blocks of code from the SimCLR framework using TensorFlow. These blocks taken from google-research/simclr with some minor changes, for simplicity. . Image preprocessing . $$ begin{align*} &amp; textbf{for} text{ sampled minibatch} {x }^{N}_{k=1} textbf{ do} &amp; textbf{for} text{ all k} in {1, ... , N } textbf{ do} &amp; text{draw two augmentation functions } mathcal{t} sim mathcal{T}, mathcal{t&#39;} sim mathcal{T} &amp; tilde{x}_{2k-1} = mathcal{t(x_k)} tilde{x}_{2k} = mathcal{t&#39;(x_k)} end{align*} $$preprocess_for_train can be seen as $ mathcal{T}$ in the training setting. For aditional implementation details, see simclr/data_util.py. . import tensorflow as tf from data_util import random_crop_with_resize, random_color_jitter def preprocess_for_train(image, height, width, color_distort=True, crop=True, flip=True): &quot;&quot;&quot;Preprocesses the given image for training. Args: image: `Tensor` representing an image of arbitrary size. height: Height of output image. width: Width of output image. color_distort: Whether to apply the color distortion. crop: Whether to crop the image. flip: Whether or not to flip left and right of an image. Returns: A preprocessed image `Tensor`. &quot;&quot;&quot; if crop: image = random_crop_with_resize(image, height, width) if flip: image = tf.image.random_flip_left_right(image) if color_distort: image = random_color_jitter(image) image = tf.reshape(image, [height, width, 3]) return image . NT-Xent loss . $$ mathsf{sim}(u,v) = dfrac{u^ intercal v}{ |u | |v |} $$ . $$ $$ . $$ ell_{i,j} = - log dfrac{ exp mathsf{sim}(z_i, z_j) / tau}{ sum_{k=1}^{2N} mathbb{1}_{[k ne i]} exp mathsf{sim}(z_i, z_j) / tau} , (1) $$ . Where x and v can be $z_i$ and $z_j$, in no particular order. For aditional implementation details, see simclr/objective.py. . LARGE_NUM = 1e9 def nt_xent_loss(x, v, temperature=1.0): batch_size = tf.shape(x)[0] masks = tf.one_hot(tf.range(batch_size), batch_size) labels = tf.one_hot(tf.range(batch_size), batch_size * 2) logits_x_x = tf.matmul(x, x, transpose_b=True) / temperature logits_x_x = logits_x_x - masks * LARGE_NUM logits_v_v = tf.matmul(v, v, transpose_b=True) / temperature logits_v_v = logits_v_v - masks * LARGE_NUM logits_x_v = tf.matmul(x, v, transpose_b=True) / temperature logits_v_x = tf.matmul(v, x, transpose_b=True) / temperature loss_x = tf.nn.softmax_cross_entropy_with_logits( labels, tf.concat([logits_x_v, logits_x_x], 1)) loss_v = tf.nn.softmax_cross_entropy_with_logits( labels, tf.concat([logits_v_x, logits_v_v], 1)) loss = tf.reduce_mean(loss_x + loss_v) return loss . Acknowledgements . I would like to thank the authors for this incredibly well written and clear contribution. . References . 1. A Simple Framework for Contrastive Learning of Visual Representations. Chen, T., Kornblith, S., Norouzi, M., &amp; Hinton, G. - 2020↩ .",
            "url": "https://joaolage.com/notes-simclr-framework",
            "relUrl": "/notes-simclr-framework",
            "date": " • Apr 5, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Building a TFRecords dataset",
            "content": "Introduction . For a long time I worked with pickle, JSON and CSV files in order to build a dataset that could be used to train a ML model. . We all know the importance to have reliable, reusable and portable datasets when training any model. . As we know, pickle files show some disadvantages: . No compression | Assumes you will have the same packages when decoding the file (example: numpy) | You cannot stream it from disk since you have to read and decode the file/part as a whole first | . What happens next? - Let me present you TFRecords! . Creating the Dataset . What is a TFRecords file? . “To read data efficiently it can be helpful to serialize your data and store it in a set of files (…)” src: TFRecords tutorials . TFRecords take advantage of protocol buffers to efficiently create a cross-platform structure of the data to be saved. The saved data is a sequence of binary records. . How do I start? . Let’s pretend our dataset is made of images, descriptions and labels. Labels will be our targets for future use. First we will need to define a protobuf and tf.train.Example will ease that work for us: . import tensorflow as tf def serialize_example(image, description, label): feature = { &quot;description_index&quot;: tf.train.Feature( int64_list=tf.train.Int64List(value=description.indices) ), &quot;description_value&quot;: tf.train.Feature( int64_list=tf.train.Int64List(value=description.data) ), &quot;image&quot;: tf.train.Feature( bytes_list=tf.train.BytesList(value=[image]) ), &quot;label&quot;: tf.train.Feature(int64_list=tf.train.Int64List(value=[label])), } example_proto = tf.train.Example(features=tf.train.Features(feature=feature)) return example_proto.SerializeToString() . The above snippet creates a structure holding a sparse vector representation for textual descriptions, a byte string for images and a list for labels . If you want to encode your text as a sequence you can easily do it without the need of having both indices and values - just values will be enough. . In regard to images, this example assumes that each image was downloaded, resized and saved previously into disk and can be loaded through its image path. . At the moment, TFRecords support three generic types, BytesList, FloatList and Int64List, but they can be coerced into many other data types. . How do I create a TFRecords file? . After having the dataset split and the vectorisers fitted, you can loop through the data splits, create a binary representation of each data point and save it to a .tfrecords file: . import os import cv2 datasets = [(train, &quot;train&quot;), (val, &quot;val&quot;), (test, &quot;test&quot;)] for dataset, file_name in datasets: file_path = os.path.join(output_dir, file_name + &quot;.tfrecords&quot;) with tf.python_io.TFRecordWriter(file_path) as writer: for row in dataset: img = cv2.imread(row[&quot;image_path&quot;]).tobytes() description = text_encoder.transform( [row[&quot;description&quot;]] ) label_encoded = label_encoder.transform(row[&quot;label&quot;]) example = serialize_example(image, description, label) writer.write(example) . For reproducibility purposes, text_encoder is a CountVectorizer object and label_encoder is a LabelBinarizer object. . . In case of using encoders for text and/or targets, I recommend to save their configuration in order to dynamically load the number of unique tokens and/or classes when training a model. After running the snippets above you will create three files train.tfrecords, val.tfrecords and test.tfrecords! . How do I read a TFRecord file? . First we need to create a representation of the feature we want to decode from each TFRecord: . feature_description = { &#39;label&#39;: tf.FixedLenFeature([], tf.int64, default_value=0), &#39;image&#39;: tf.FixedLenFeature([], tf.string), &#39;description&#39;: tf.SparseFeature(index_key=&quot;description_index&quot;, value_key=&quot;description_value&quot;, dtype=tf.int64, size=description_max_features), } . Luckily we have the ability to turn an array of indices and an array of values into a sparse feature without much hassle with tf.SparseFeature, just by specifying where to read the indices, values and the maximum length of the sparse representation. Please note that for every example: len(indices) == len(values) and indices should be contained in [0,...,max_features-1]. . Then we create a parsing function that reads the byte string of each example and decodes it: . def _parse_function(example_proto): example = tf.parse_single_example(example_proto, feature_description) label = example[&quot;label&quot;] description = example[&quot;description&quot;] image_shape = tf.constant([128, 128, 3]) image = tf.decode_raw(example[&quot;image&quot;], tf.uint8) image = tf.reshape(image, image_shape) return { &quot;description&quot;: description, &quot;image&quot;:image, }, label . Tip: If you wish to turn a sparse tensor into dense you can use tf.sparse.to_dense. . Tip: Using pre-trained imagenet weights? . If using an image model initialised with imagenet weights you should subtract the channel mean on each pixel using the below function. Also, channels will be swapped from RGB to BGR. This preprocessing stage guarantees that you will be sourcing images to the model following the same pixel value distribution per channel from the imagenet’s dataset. . The code block below is a simplified version of the current Keras implementation that assumes the x tensor to have color channels in the last dimension and channels input order should be RGB. . def preprocess_symbolic_input(x): backend = tf.keras.backend data_format = &quot;channels_last&quot; # &#39;RGB&#39;-&gt;&#39;BGR&#39; x = x[..., ::-1] mean = [103.939, 116.779, 123.68] mean_tensor = backend.constant(-np.array(mean)) # Zero-center by mean pixel if backend.dtype(x) != backend.dtype(mean_tensor): x = backend.bias_add( backend.cast(x, backend.dtype(mean_tensor)), mean_tensor, data_format=data_format, ) else: x = backend.bias_add(x, mean_tensor, data_format=&quot;channels_last&quot;) return x . Finally, we create an helper to reads the datasets: . def read_dataset(file, shuffle=False, batch_size=64, prefetch=5): dataset = tf.data.TFRecordDataset(file) if shuffle: dataset = dataset.shuffle() return dataset.map(_parse_function) train_dataset = read_dataset(&quot;train.tfrecords&quot;) val_dataset = read_dataset(&quot;val.tfrecords&quot;) test_dataset = read_dataset(&quot;test.tfrecords&quot;) . Fitting a model . A TFRecord dataset is also know by its versatility since it can be used when fitting a tf.keras.Model (see docs) and also when training an instance of tf.estimator.Estimator (see: docs and guide). . def input_fn_train(model_path, batch_size): dataset = read_dataset(model_path) dataset = dataset.repeat() dataset = dataset.shuffle(buffer_size=5) dataset = dataset.batch(batch_size) return dataset.prefetch(buffer_size=5) def input_fn_eval(model_path, batch_size): dataset = read_dataset(model_path) dataset = dataset.batch(batch_size) dataset = dataset.repeat() return dataset.prefetch(buffer_size=5) . Voilà! You are now able to feed batches of tfrecords into your model! .",
            "url": "https://joaolage.com/building-tfrecords-dataset/",
            "relUrl": "/building-tfrecords-dataset/",
            "date": " • Sep 17, 2019"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "I have an increasing curiosity towards computers, electronics and science. I hold a MSc in Electronics and Computer Engineering and I classify myself as a passionate for technology and science. . My area of focus is Machine Learning and AI, where I have been developing and applying state of the art research for the past 4 years, ranging from Data Analysis, NLP and Computer Vision. . I am also very passionate for open source software, community driven solutions, traveling and life itself :) . .",
          "url": "https://joaolage.com/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://joaolage.com/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}